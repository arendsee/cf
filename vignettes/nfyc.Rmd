---
title: "NF-YC gene family case study"
author: "Zebulun Arendsee"
date: "`r Sys.Date()`"
bibliography: synder.bib 
output:
    rmarkdown::html_vignette:
        fig_caption: yes 
vignette: >
  %\VignetteIndexEntry{NFYC case study}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

This is an internal vignette that uses local data. I'll make the data
accessible soon, but for now you shouldn't use this vignette.

```{r, eval=FALSE}
require(ape)
tree <- read.tree('arabidopsis/tree')
pdf('tree.pdf')
plot(tree)
dev.off()
```

```{r, eval=FALSE}

blastp_map <- function(){
  # blastp <- read.table(
  #   blastp,
  #   header=TRUE,
  #   stringsAsFactors=FALSE
  # )
  # besthits <- dplyr::group_by(blastp, qseqid) %>%
  #   dplyr::summarize(top_evalue = min(evalue))
  # merge(
  #   blastp,
  #   geneMap,
  #   by.x=c('qseqid', 'sseqid'),
  #   by.y=c('mrna', 'xx')
  # ) %>%
  #   dplyr::arrange(name) %>%
  #   merge(besthits, by='qseqid')
}

as_grange <- function(x, xid, xa, xb){
  GenomicRanges::GRanges(
    seqnames=x[[xid]],
    ranges=IRanges::IRanges(
      start = pmin(x[[xa]], x[[xb]]),
      end = pmax(x[[xa]], x[[xb]])
    )
  )
}

remove_rownames <- function(d){
  rownames(d) <- NULL
  d
}

overlaps <- function(x, xid, xa, xb, y, yid=xid, ya=xa, yb=xb, add_id=TRUE){
  # add unique ID to each row in each input table
  if(add_id){
    x$xid <- 1:nrow(x)
    y$yid <- 1:nrow(y)
  }
  # convert each input table to a GRanges object
  xrng <- as_grange(x, xid, xa, xb)
  GenomicRanges::mcols(xrng) <- x[, which(!(names(x) %in% c(xid, xa, xb)))]
  yrng <- as_grange(y, yid, ya, yb)
  GenomicRanges::mcols(yrng) <- y[, which(!(names(y) %in% c(yid, ya, yb)))]
  # find the interval overlaps
  hits <- GenomicRanges::findOverlaps(xrng, yrng, ignore.strand=TRUE) 
  # extract a table of overlapping rows from the GRanges object
  dodt <- function(z, ids, id, a, b){
    z <- as.data.frame(z)[ids, ]
    z$strand <- NULL
    z$width <- NULL
    names(z)[1:3] <- c(id, a, b)
    for(n in c("seqname", "start", "stop", "width", "strand")){
      if(any(paste0(n, ".1") %in% names(z))){
        names(z)[names(z) %in% paste0(n, ".1")] <- n
      }
    }
    z
  }
  x2 <- dodt(xrng, S4Vectors::queryHits(hits), xid, xa, xb)
  y2 <- dodt(yrng, S4Vectors::subjectHits(hits), yid, ya, yb)
  # bind the two tables together
  cbind(x2, y2)
}

make_tblastn_gene_map <- function(tblastn, tgff){
  overlaps(
    x=tblastn, y=as.data.frame(tgff),
    xid="sseqid", xa="sstart", xb="send",
    yid="seqid", ya="start", yb="stop"
  ) %>%
    dplyr::select(
      ## the focal protein that was BLASTed
      fprot_id = qseqid,
      fprot_start = qstart,
      fprot_stop = qend,
      ## the target genomic intervals with translated coding similarity
      tchr = sseqid,
      tn_start = sstart,
      tn_stop = send,
      tn_evalue = evalue,
      tn_ppos = ppos,
      tn_frame = sframe,
      tn_id = tblastn_id,
      ## the target feature that overlaps the region of similarity
      tfeat_name = attr,
      tfeat_start = start,
      tfeat_stop = stop,
      tfeat_src = source,
      tfeat_type = type,
      tfeat_strand = strand
    ) %>% remove_rownames
}

make_tblastn_si_map <- function(tblastn, synres){
  x <- dplyr::select(tblastn,
    # the focal protein that was BLASTed
    fprot_id = qseqid,
    fprot_start = qstart,
    fprot_stop = qend,
    # the target genomic intervals with translated coding similarity
    tchr = sseqid,
    tn_start = sstart,
    tn_stop = send,
    tn_evalue = evalue,
    tn_ppos = ppos,
    tn_frame = sframe,
    tn_id = tblastn_id
  )
  y <- dplyr::select(as.data.frame(synres),
    # synder search interval info
    ## * focal query interval
    fseqid = attr,
    fchr = qseqid,
    si_fstart = qstart,
    si_fstop = qstop,
    ## * target search interval
    si_tchr = tseqid,
    si_tstart = tstart,
    si_tstop = tstop,
    orientation = strand,
    ## * synder stats
    si_score = score,
    cset = cset,
    l_flag = l_flag,
    r_flag = r_flag,
    inbetween = inbetween
  )
  overlaps(x, y,
           xid="tchr", xa="tn_start", xb="tn_stop",
           yid="si_tchr", ya="si_tstart", yb="si_tstop", add_id=FALSE) %>%
    dplyr::select(-si_tchr) %>%
    dplyr::select(
      # focal protein
      fprot_id, fprot_start, fprot_stop,
      # region of coding similarity found by tBLASTn 
      tchr, tn_start, tn_stop, tn_frame,
      # tBLASTn stats
      tn_evalue, tn_ppos,
      # synder search interval
      fseqid, cset,
      # - focal region
      fchr, si_fstart, si_fstop,
      # - target region
      si_fstart, si_fstop, orientation,
      # - synder stats
      si_score, l_flag, r_flag, inbetween
    ) %>% remove_rownames
}
```

```{r, eval=FALSE}
require(synder)
require(GenomicRanges)
require(dplyr)
require(Biostrings)
require(CNEr)

extractNameFromAttr <- function(x){
  sub(".*Name=([^;]+).*", "\\1", x)
}

# fgff="arabidopsis/gff/yc.gff"
# gene_map="arabidopsis/yc.tab"
# syn="arabidopsis/syn/at-vs-es.syn"
# tgff="arabidopsis/gff/es.gff"
# tblastn="arabidopsis/es.blast.tab"
# blastp=NULL
# k=0L
# r=0
# trans="d"
featureMatch <- function(
    syn,
    fgff,
    tgff,
    gene_map,
    tblastn,
    k      = 0L,
    r      = 0,
    trans  = "d",
    blastp = NULL
){
  syn  <- synder::as_synmap(syn)
  fgff <- synder::as_gff(fgff)
  GenomicRanges::mcols(fgff)$attr <- extractNameFromAttr(GenomicRanges::mcols(fgff)$attr)

  tgff <- synder::as_gff(tgff)
  tgff <- tgff[tgff$type == "mRNA"]
  GenomicRanges::mcols(tgff)$attr <- extractNameFromAttr(GenomicRanges::mcols(tgff)$attr)

  nfyc <- read.table(
      gene_map,
      col.names=c("name", "gene", "mrna"),
      stringsAsFactors=FALSE
  )

  result <- synder::search(syn, fgff, k=k,r=r,trans=trans)

  feats <- featureMap(srcres=result, fgff=fgff, tgff=tgff)

  tblastn <- read.table(
    tblastn_file,
    header=TRUE,
    stringsAsFactors=FALSE
  )
  tblastn$tblastn_id <- 1:nrow(tblastn)

  tblastn_si_map <- make_tblastn_si_map(tblastn, result)
  tblastn_gene_map <- make_tblastn_gene_map(tblastn, tgff)

  #### TODO: continue from here

  # prot_cmp <- if(is.null(blastp)){
  #   NULL
  # } else {
  #   blastp_map()
  # }
  #
  # list(
  #   synres   = result,
  #   nfyc     = nfyc,
  #   genemap  = geneMap,
  #   prot_cmp = prot_cmp,
  #   geno_cmp = geno_cmp,
  #   fgff     = fgff,
  #   tgff     = tgff
  # )
}

files <- list(
  al=list(syn="syn/at-vs-al.syn", gff="gff/al.gff", tblastn="al.blast.tab", blastp="yc-vs-al.blast.tab"),
  cr=list(syn="syn/at-vs-cr.syn", gff="gff/cr.gff", tblastn="cr.blast.tab"),
  br=list(syn="syn/at-vs-br.syn", gff="gff/br.gff", tblastn="br.blast.tab"),
  es=list(syn="syn/at-vs-es.syn", gff="gff/es.gff", tblastn="es.blast.tab")
)

results <- lapply(files, function(x){
  featureMatch(
    fgff="arabidopsis/gff/yc.gff",
    gene_map="arabidopsis/yc.tab",
    syn=paste0("arabidopsis/", x$syn),
    tgff=paste0("arabidopsis/", x$gff),
    tblastn=paste0("arabidopsis/", x$tblastn),
    blastp=if(!is.null(x$blastp)){paste0("arabidopsis/", x$blastp)}else{NULL},
    k=0L, r=0, trans="d"
  )
})

# one row per gene
buildTables <- function(x){
    emax <- 0.001
    d <- as.data.frame(x$geno_cmp$syn)
    d$gene <- as.character(d$gene)
    d$strand <- as.character(d$strand)
    # NOTE: here the strands for the query and target are ignored. This is
    # because they are always '+'. Only the relative orientation matters
    # in the synteny map.
    d <- dplyr::select(d,
        gene         = gene,
        qchr         = first.seqnames,
        qstart       = first.start,
        qend         = first.end,
        tchr         = second.seqnames,
        si_start     = second.start,
        si_end       = second.end,
        si_score     = score,
        orientation  = strand,
        cset         = cset,
        l_flag       = l_flag,
        r_flag       = r_flag,
        inbetween    = inbetween,
        id           = id
    )

    fgff <- as.data.frame(x$fgff)
    fgff$gene <- extractNameFromAttr(fgff$attr)
    fgff$attr <- NULL

    ### Get the query strand from the GFF
    stopifnot(fgff$type == "gene")
    stopifnot(length(fgff$gene) == length(unique(fgff$gene)))
    # NOTE: not all genes in the GFF are required to be in d, since some may
    # have no target genes overlapping targets search intervals.
    stopifnot(d$gene %in% fgff$gene)
    # merge all columns, just for testing
    tst <- merge(d, fgff, by="gene")
    stopifnot(tst$start == tst$qstart)
    stopifnot(tst$end == tst$end)
    stopifnot(tst$seqnames == tst$qchr)
    # then merge in just the single column we need (strand)
    d2 <- merge(d, fgff[, c("strand", "gene")]) %>%
        dplyr::rename(qstrand=strand)

    ### Merge in tblastn results
    blastout <- x$geno_cmp$hit %>%
      # in tn_*, tn stands for tblastn 
      dplyr::select(
        tchr      = seqnames,
        tn_gene   = gene,
        tn_qseqid = qseqid,
        tn_sstart = start,
        tn_send   = end,
        tn_qlen   = qlen,
        tn_slen   = slen,
        tn_length = length,
        tn_evalue = evalue,
        tn_ppos   = ppos,
        tn_qstart = qstart,
        tn_qend   = qend,
        tn_sframe = sframe
      ) %>%
      dplyr::mutate(
        tn_strand = ifelse(tn_sframe > 0, '+', '-')
      )

    # The hit table contains BLAST hits of the query protein sequences against
    # the target genome (tBLASTn) that overlap search intervals. The `qseqid` in
    # the blast table is the protein that was searched. The `gene` column in d2
    # is the gene that was linked through synder to the common search interval.
    # Therefore `gene` and `qseqid` do not have to be the same gene. If they are
    # the same gene, that means the BLAST hit is in agreement with the synder
    # search interval. If they are not the same gene, then this means more than
    # one NF-YC gene is similar to something in the search interval.
    stopifnot(nrow(blastout) == nrow(d2))
    # test for overlap
    stopifnot(blastout$tchr == d2$tchr)
    stopifnot(d2$si_start < blastout$tn_ssend)
    stopifnot(blastout$tn_start < d2$si_end)
    # join them columnwise
    d4 <- as.data.frame(append(as.list(d2), as.list(blastout)), stringsAsFactors=FALSE)

    # merge in gene names
    d5 <- merge(dplyr::distinct(x$nfyc[, c("name", "gene")]), d4, by='gene')
    stopifnot(nrow(d5) == nrow(d))

    matches <- subset(d5,
      gene == tn_gene &
      (
       (orientation == "+" & (qstrand == tn_strand)) |
       (orientation == "-" & (qstrand != tn_strand))
      ) &
      tn_evalue < emax
    )

    # number of contiguous sets for each gene (before looking at blast)
    syn <- as.data.frame(x$synres)
    syn$gene <- extractNameFromAttr(syn$attr)
    n_si <- dplyr::group_by(syn, gene) %>%
        dplyr::summarize(
          n_si = length(unique(cset))
        ) %>%
        dplyr::arrange(gene)

    # prediction of homolog based solely on synder
    genemap = dplyr::rename(x$genemap, gene=at, tgene=xx)
    synder_pred <- dplyr::group_by(genemap, gene) %>%
        dplyr::summarize(
            # number of search intervals found for this query
            synder_n_si = length(unique(cset)),
            # number of target species genes that overlap the search intervals
            synder_n_tgenes = length(unique(tgene)),
            # target gene ids that overlap search intervals 
            synder_tgenes = paste0(unique(tgene), collapse=";")
        ) %>%
        dplyr::arrange()

    # Number of significant tBLASTn hits for each query gene against the target
    # genome. For queries with multiple transcripts, the number of hits for the
    # transcript with the most hits is selected.
    allblast <- x$geno_cmp$all
    allblast$gene <- sub("\\.[0-9]+", "", allblast$qseqid)
    n_blast <- dplyr::group_by(allblast, qseqid) %>%
        dplyr::filter(evalue < emax) %>%
        dplyr::summarize(
          blast_n_hits = length(qseqid),
          gene=gene[1]
        ) %>%
        dplyr::group_by(gene) %>%
        dplyr::summarize(blast_n_hits = max(blast_n_hits))

    # Number of different NF-YC genes that have a hit to a search interval for each gene.
    n_paralog <- dplyr::group_by(d5, tn_gene) %>%
        dplyr::filter(tn_evalue < emax) %>%
        dplyr::summarize(n_paralog = length(unique(gene)))

    # Take the best BLAST hit that overlaps a search interval for each query
    # gene. If BLAST and Synder agree, this search interval will be for the query
    # gene.
    blast_pred <- dplyr::group_by(d5, tn_gene) %>%
        dplyr::filter(tn_evalue == min(tn_evalue)) %>%
        dplyr::summarize(blast_pred = gene[1])

    ##### Need to find overlap between the target genes in the genemap and the
    ##### blast results
    # # prediction based on best hit within syntenic interval
    # joint_pred <- dplyr::group_by(matches, gene) %>%
    #     dplyr::filter(tn_evalue == min(tn_evalue)) %>%
    #     dplyr::select(gene, tn_gene) %>%
    #     dplyr::distinct() %>%
    #     dplyr::arrange()

    ## TODO: figure out where x$geno_cmp$gene_matches went

    # number of contiguous sets for each gene after syncing with blast
    n_si_blast <- dplyr::group_by(matches, gene) %>%
        dplyr::summarize(n_si = length(unique(cset)))


    list(matches=matches)
}

tabs <- lapply(results, buildTables)
for (n in names(tabs)){
    tabs[[n]]$target_species = n
}
ds <- do.call(rbind, tabs)
rownames(ds) = NULL

# make table with columns: n_si | n_blast | n_both
# the si should first be filtered by strand
final <- dplyr::group_by(ds, qseqid, target_species) %>%
  dplyr::filter(
    
  ) %>%
  dplyr::summarize(
    n_si = length(unique(cset))
  )
```
